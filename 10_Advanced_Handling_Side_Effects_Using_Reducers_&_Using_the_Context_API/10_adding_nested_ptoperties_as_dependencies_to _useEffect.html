<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adding Nested Properties As Dependencies to useEffect</title>
</head>
<body>
    <!--
            - In the previous lecture, we used object destructuring to add object properties as dependencies to useEffect().

                                        const { someProperty } = someObject;
                                        useEffect(() => {
                                        // code that only uses someProperty ...
                                        }, [someProperty]);

            - This is a very common pattern and approach, which is why I typically use it and why I show it here 
        (I will keep on using it throughout the course).

        NOTE: 
            The key thing is NOT that we use destructuring but that we pass specific properties instead of the entire object as a dependency.

         - We could also write this code and it would work in the same way.

                                        useEffect(() => {
                                        // code that only uses someProperty ...
                                        }, [someObject.someProperty]);

            - this works just fine as well

        but should avoid this code

                                        useEffect(() => {
                                        // code that only uses someProperty ...
                                        }, [someObject]);

            Because now the effect function would re-run whenever ANY property of someObject changes 
            - not just the one property (someProperty in the above example) our effect might depend on.
    -->
</body>
</html>